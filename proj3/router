#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, math

#DEBUG = True
DEBUG = False

parser = argparse.ArgumentParser(description='route packets')
parser.add_argument('asn', type=int, help="AS Number")
parser.add_argument('networks', metavar='networks', type=str, nargs='+', help="networks")
args = parser.parse_args()

##########################################################################################

# Message Fields
TYPE = "type"
SRCE = "src"
DEST = "dst"
MESG = "msg"
TABL = "table"

# Message Types
DATA = "data"
DUMP = "dump"
UPDT = "update"
RVKE = "revoke"
NRTE = "no route"

# Update Message Fields
NTWK = "network"
NMSK = "netmask"
ORIG = "origin"
LPRF = "localpref"
APTH = "ASPath"
SORG = "selfOrigin"

# internal route info
CUST = "cust"
PEER = "peer"
PROV = "prov"


##########################################################################################

class Router:

  routes = None
  updates = None
  relations = None
  sockets = None

  def __init__(self, networks, asn):
    self.asn = asn
    self.routes = []
    self.updates = []
    self.relations = {}
    self.sockets = {}
    for relationship in networks:
      # networks comes in the form of ip.add.re.ss-relation

      # splits along the '-'
      network, relation = relationship.split("-")
      if DEBUG:
        print("Starting socket for", network, relation)

      # creates a non-blocking socket connected to the network representing a port on the router
      self.sockets[network] = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
      self.sockets[network].setblocking(0)
      self.sockets[network].connect(network)

      self.relations[network] = relation
    return

  def within_subnet(self, daddr, ntwk, nmsk):
    """ check if destination address is in the subnet"""
    matching = True
    dest_l = daddr.split('.')
    ntwk_l = ntwk.split('.')
    nmsk_l = nmsk.split('.')
    prefix = []

    for ii in range(len(nmsk_l)):
      x = (int(nmsk_l[ii]) & int(dest_l[ii]))
      if x != 0: prefix.append(x)
    for jj in range(len(prefix)):
      if not int(ntwk_l[jj]) == int(prefix[jj]):
        matching = False

    return matching

  def lookup_routes(self, daddr):
    """ Lookup all valid routes for an address """
    outroutes = []

    for table_entry in self.routes:
      if self.within_subnet(daddr, table_entry[NTWK], table_entry[NMSK]):
        outroutes.append(table_entry)

    return outroutes

  def get_shortest_as_path(self, routes):
    """ select the route with the shortest AS Path """
    outroutes = []
    min = float('inf')

    for route in routes:
      if len(route[APTH]) < min:
        min = len(route[APTH])
        outroutes = [route]
      elif route == min:
        outroutes.append(route)

    return outroutes

  def get_highest_preference(self, routes):
    """ select the route with the highest preference """
    outroutes = []
    max = float('-inf')

    for route in routes:
      if DEBUG: print("Network:", route[NTWK], "Local pref:", route[LPRF], "Peer:", route[PEER])
      if route[LPRF] > max:
        max = (route[LPRF])
        outroutes = [route]
      elif route == max:
        outroutes.append(route)

    if DEBUG: print("Outroutes:", outroutes)
    return outroutes

  def get_self_origin(self, routes):
    """ select self originating routes """
    outroutes = []

    for route in routes:
      if route[SORG] is True:
        outroutes.append(route)
    return outroutes if len(outroutes) > 0 else routes

  def get_origin_routes(self, routes):
    """ select origin routes: IGP > EGP > UNK """
    IGP = []
    EGP = []
    UNK = []

    for route in routes:
      if route[ORIG] == 'IGP':
        IGP.append(route)
      if route[ORIG] == 'EGP':
        EGP.append(route)
      if route[ORIG] == 'UNK':
        UNK.append(route)

    if len(IGP) > 0:
      return IGP
    elif len(EGP) > 0:
      return EGP
    else:
      return UNK

  def compare_address(self, route, min):
    """ check for lowest ip adress given routes"""
    route_split = route.split('.')
    min_split = min.split('.')

    for quad in range(4):
      if route_split[quad] < min_split[quad]:
        return True
      if route_split[quad] > min_split[quad]:
        break

    return False

  def get_lowest_address(self, routes):
    """ check for lowest ip adress given routes"""

    min = '999.999.999.999'

    for route in routes:
      if self.compare_address(route[PEER], min):
        min = route

    return [min]

  def filter_relationships(self, srcif, routes):
    """ Don't allow Peer->Peer, Peer->Prov, or Prov->Peer forwards """
    outroutes = []

    for route in routes:
      source_relat = self.relations[srcif]
      dest_relat = self.relations[route[PEER]]


      if source_relat == CUST:
        outroutes.append(route)

    return outroutes

  def get_route(self, srcif, daddr):
    """	Select the best route for a given address	"""
    peer = None
    routes = self.lookup_routes(daddr)
    if DEBUG: print("Routes", routes)
    routes = self.get_longest_prefixes(routes)
    if DEBUG: print("Routes", routes)
    # Rules go here
    if routes:
      # 1. Highest Preference
      routes = self.get_highest_preference(routes)
      # 2. Self Origin
      routes = self.get_self_origin(routes)
      # 3. Shortest ASPath
      routes = self.get_shortest_as_path(routes)
      # 4. IGP > EGP > UNK
      routes = self.get_origin_routes(routes)
      # 5. Lowest IP Address
      routes = self.get_lowest_address(routes)
      # Final check: enforce peering relationships
      routes = self.filter_relationships(srcif, routes)
      # We can assume that we have the single best route
      peer = routes[0][PEER]
    return self.sockets[peer] if peer else None

  def adjust_addr(self, addr):
    """ Flips final digit of an address"""

    if (addr[-1] == '1'):
      return addr[:-1] + '2'
    if (addr[-1] == '2'):
      return addr[:-1] + '1'

  def get_prefix(self, nmsk):
    bb = bin(struct.unpack('!I', socket.inet_aton(nmsk))[0])[2:]
    return bb.count('1')

  def get_longest_prefixes(self, routes):
    """ check for longest prefix amongst given routes"""

    longest_prefixes = []
    max = 0

    for route in routes:
      curr_pref = self.get_prefix(route[NMSK])
      if curr_pref > max:
        max = curr_pref
        longest_prefixes = [route]
      elif curr_pref == max:
        longest_prefixes.append(route)

    return longest_prefixes


  def forward(self, srcif, packet):
    """	Forward a data packet	"""

    avail_routes = self.lookup_routes(packet[DEST])
    num_routes = len(avail_routes)

    k = json.dumps(packet)

    if num_routes == 0:
      self.send_error(srcif, packet)
    elif num_routes == 1:
      self.sockets[avail_routes[0][PEER]].sendall(bytes(k, "utf-8"))
    else:
      self.get_route(srcif, packet[DEST]).sendall(bytes(k, "utf-8"))

    return True

  def coalesce(self):
    """	coalesce any routes that are right next to each other	"""
    # TODO (this is the most difficult task, save until last)
    return False

  def create_entry(self, packet):
    """ create a forwarding table entry"""
    network = packet[MESG][NTWK]
    netmask = packet[MESG][NMSK]
    peer = self.adjust_addr(packet[DEST])
    localpref = packet[MESG][LPRF]
    self_origin = packet[MESG][SORG]
    as_path = packet[MESG][APTH]
    orgin = packet[MESG][ORIG]

    return {NTWK: network, NMSK: netmask, PEER: peer, LPRF: localpref, SORG: self_origin, APTH: as_path, ORIG: orgin}

  def update(self, srcif, packet):
    """	handle update packets	"""
    if not srcif:
      return False

    # Store a copy of the announcement
    self.updates.append(packet[MESG])

    # Store entry to forwarding table
    self.routes.append(self.create_entry(packet))

    msg = packet[MESG]
    msg[APTH].append(self.asn)

    # Send copies of the announcement to neighbors
    for sock in self.sockets:

      if sock != srcif:
        new_packet = {SRCE: self.adjust_addr(sock), DEST: sock, TYPE: UPDT, MESG: msg}
        k = json.dumps(new_packet)
        self.sockets[sock].sendall(bytes(k, "utf-8"))

    return True

  def revoke(self, packet):
    """	handle revoke packets	"""
    # TODO
    return True

  def dump(self, packet):
    """	handles dump table requests	"""
    k = json.dumps({SRCE: packet[DEST], DEST: packet[SRCE], TYPE: TABL, MESG: self.routes})
    self.sockets[packet[SRCE]].sendall(bytes(k, "utf-8"))
    return True

  def handle_packet(self, srcif, packet):
    """	dispatches a packet """
    if not srcif:
      return False

    if packet[TYPE] == UPDT:
      return self.update(srcif, packet)
    elif packet[TYPE] == RVKE:
      # TODO
      return self.revoke(srcif, packet)
    elif packet[TYPE] == DATA:
      return self.forward(srcif, packet)
    elif packet[TYPE] == NRTE:
      # TODO
      return False
    elif packet[TYPE] == DUMP:
      # TODO
      return self.dump(packet)
    elif packet[TYPE] == TABL:
      # TODO
      return False
    else:
      if (DEBUG): print("DEBUG:", packet[TYPE], "is not a valid type")
      return False

    if (DEBUG): print("DEBUG: THIS CASE SHOULD NEVER BE EVALUATED")

  def send_error(self, conn, msg):
    """ Send a no_route error message """
    '2' + 2

    dict = {SRCE: "", DEST: msg[SRCE], TYPE: NRTE, MESG: {}}
    conn.sendall(bytes(json.dumps(dict), "utf-8"))

  def run(self):
    while True:
      readable_socks = select.select(self.sockets.values(), [], [], 0.1)[0]
      for conn in readable_socks:
        try:
          k = conn.recv(65535)
        except:
          # either died on a connection reset, or was SIGTERM's by parent
          return
        if k:
          for sock in self.sockets:
            if self.sockets[sock] == conn:
              srcif = sock

          packet = json.loads(k)

          if not self.handle_packet(srcif, packet):
            self.send_error(conn, packet)
        else:
          return
    return

if __name__ == "__main__":
  router = Router(args.networks, args.asn)
  router.run()